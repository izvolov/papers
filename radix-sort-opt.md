Оптимизация поразрядной сортировки
Поразрядная сортировка, естественно

Известно, что алгоритмы обладают такими характеристиками, как алгоритмическая сложность и потребление памяти.
К примеру, быстрая сортировка в худшем случае работает за O(n^2) времени и потребляет O(1) дополнительной памяти.
А поразрядная сортировка работает за O(n) и потребляет O(n) памяти.

Но кроме алгоритмической сложности, или асимптотики, есть ещё свойство естественности. Алгоритм в процессе своей работы каким-то образом преобразует входные данные, достигая какого-то результата. При этом входные данные могут быть близки к выходным. Например, на вход сортировки может прийти уже отсортированный диапазон.
Алгоритм тем более естественен, чем меньше он делает в случае "хороших" входных данных.
Быстрая сортировка, и особенно её гибридные реализации, например, в STL, обладает высокой степенью естественностью.
А вот классическая поразрядная сортировка, наоборот, наименее естественна.
Действительно, алгоритм поразрядной сортировки таков, что она последовательно проходит по каждому разряду, собирает счётчики, а затем переставляет все элементы в буфер. То есть независимо от входных данных она всегда делает одно и то же.
Поэтому, хотя поразрядка и опережает стандартные сортировки на случайных массивах, на отсортированных массивах она сильно проигрывает.
В отличие от сортировок сравнениями, поразрядная сортировка ничего не знает про порядок элементов. Она знает только целые числа, в которые отображаются сортируемые элементы. Но на целых числах порядок нам всегда известен! К тому же поразрядка всегда сортирует по возрастанию. Значит, кое-что нам всё-таки известно. И мы это используем для оптимизации.

Для начала, напомню алгоритм.
1.  Проходим один раз по диапазону.
    Для каждого разряда собираем массив счётчиков.
2.  Для каждого разряда переставляем все элементы в буфер согласно порядку, определённому счётчиками этого разряда.

Алгоритм очень простой. В этом его и преимущества, и недостатки. Попробуем избавиться от недостатков.

Естественность — это более широкое понятие, чем просто игнорирование отсортированных входных данных. Для каждого алгоритма естественность зависит от того, что он непосредственно делает.

Поразрядная сортировка при сборе счётчиков _всегда_ проходит последовательно по всему входному диапазону. При этом мы уже выяснили, что сортировка происходит по возрастанию целых чисел, полученных отображением исходных объектов.
Значит, мы при этом проходе можем проверить, отсортированы ли уже входные объекты, и если отсортированы, то полностью исключить второй этап алгоритма. это значит, что мы вообще не будем перекладывать входные объекты, и это радикально ускорит работу алгоритма на отсортированных данных.

Действие второе
----

Если на первом шаге мы поняли, что входные элементы не отсортированы, то делать нечего, нужно идти дальше.
Теперь посмотрим, что происходит на втором шаге.

Счётчики подсчитаны, позиции элементов известны, и нужно только переставить их местами.
Но можно ли что-нибудь выжать из значений счётчиков? Оказывается, можно.
Посмотрим, что значит "естественность" на этом шаге. Счётчики всегда идут в неубывающем порядке, и их значения сами по себе ничего не говорят. Но что если максимальное значение счётчика равно размеру сортируемого диапазона? Это значит, что данный разряд одинаковый для всего диапазона.

![картинка](png)

Одинаковые элементы — значит, отсортированные. То есть как минимум этот разряд сортировать не нужно, и можно его просто целиком перенести в буфер.

Идём дальше.

Берём следующий разряд.
Допустим, следующий разряд тоже отсортирован. Значит, его тоже можно просто перенести из буфера обратно во входной массив.

Получается, что мы совершили бесполезную работу: сначала перенесли весь массив в буфер, а потом вернули обратно.
Вывод: мы могли бы вообще этого не делать.

Таким образом, если два разряда подряд отсортированы, то можно их просто пропускать.

Прелесть в том, что при сортировке целых чисел это довольно частая ситуация. Допустим, мы сортируем 32-битные числа, но значения в них по факту не превышают 65535 (16 непустых разрядов). К примеру, id каких-нибудь объектов. В этом случае первые два разряда всегда равны нулю. Значит, из 4 разрядов мы оперируем только с двумя последними, а первые два всегда пропускаем. В результате второй шаг сортировки ускоряется в два раза.

Если сортируются 64-разрядные числа, то вероятность пропустить пару соседних разрядов ещё больше повышается.

Замеры
-----

было/стало
